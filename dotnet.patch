diff --git a/src/libraries/System.Private.Xml/src/System/Xml/Serialization/ReflectionXmlSerializationReader.cs b/src/libraries/System.Private.Xml/src/System/Xml/Serialization/ReflectionXmlSerializationReader.cs
index f1f08d054..c0beeb67c 100644
--- a/src/libraries/System.Private.Xml/src/System/Xml/Serialization/ReflectionXmlSerializationReader.cs
+++ b/src/libraries/System.Private.Xml/src/System/Xml/Serialization/ReflectionXmlSerializationReader.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using System.Linq.Expressions;
 using System.Reflection;
 using System.Runtime.CompilerServices;
@@ -579,7 +580,59 @@ private static void AddObjectsIntoTargetCollection(object targetCollection, List
             }
             else
             {
-                MethodInfo? addMethod = targetCollectionType.GetMethod("Add");
+                MethodInfo? addMethod = null;
+
+                // Try to find the most specific Add method by looking at the actual item type
+                if (sourceCollection.Count > 0 && sourceCollection[0] != null)
+                {
+                    Type itemType = sourceCollection[0]!.GetType();
+                    addMethod = targetCollectionType.GetMethod("Add", new Type[] { itemType });
+
+                    // If exact match not found, try to find compatible Add method
+                    if (addMethod == null)
+                    {
+                        MethodInfo[] allMethods = targetCollectionType.GetMethods();
+                        foreach (MethodInfo method in allMethods)
+                        {
+                            if (method.Name == "Add")
+                            {
+                                ParameterInfo[] parameters = method.GetParameters();
+                                if (parameters.Length == 1)
+                                {
+                                    Type paramType = parameters[0].ParameterType;
+                                    if (paramType.IsAssignableFrom(itemType))
+                                    {
+                                        addMethod = method;
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+                // Fallback: try GetMethod("Add") but handle AmbiguousMatchException
+                if (addMethod == null)
+                {
+                    try
+                    {
+                        addMethod = targetCollectionType.GetMethod("Add");
+                    }
+                    catch (AmbiguousMatchException)
+                    {
+                        // When ambiguous, find the first Add method that takes a single parameter
+                        MethodInfo[] allMethods = targetCollectionType.GetMethods();
+                        foreach (MethodInfo method in allMethods)
+                        {
+                            if (method.Name == "Add" && method.GetParameters().Length == 1)
+                            {
+                                addMethod = method;
+                                break;
+                            }
+                        }
+                    }
+                }
+
                 if (addMethod == null)
                 {
                     throw new InvalidOperationException(SR.XmlInternalError);
@@ -612,15 +665,21 @@ private static ReflectionXmlSerializationReaderHelper.SetMemberValueDelegate Get
                         MemberInfo memberInfo = ReflectionXmlSerializationHelper.GetEffectiveSetInfo(o.GetType(), memberName);
                         Debug.Assert(memberInfo != null, "memberInfo could not be retrieved");
 
-                        if (type.IsValueType || !RuntimeFeature.IsDynamicCodeSupported)
+                        if (type.IsValueType || true)
                         {
                             if (memberInfo is PropertyInfo propInfo)
                             {
-                                result = new ReflectionXmlSerializationReaderHelper.SetMemberValueDelegate(propInfo.SetValue);
+                                // Lambda is required to avoid TargetParameterCountException due to SetValue overload ambiguity
+#pragma warning disable IDE0200 // Remove unnecessary lambda expression
+                                result = new ReflectionXmlSerializationReaderHelper.SetMemberValueDelegate((obj, val) => propInfo.SetValue(obj, val));
+#pragma warning restore IDE0200
                             }
                             else if (memberInfo is FieldInfo fieldInfo)
                             {
-                                result = new ReflectionXmlSerializationReaderHelper.SetMemberValueDelegate(fieldInfo.SetValue);
+                                // Lambda is required to avoid TargetParameterCountException due to SetValue overload ambiguity
+#pragma warning disable IDE0200 // Remove unnecessary lambda expression
+                                result = new ReflectionXmlSerializationReaderHelper.SetMemberValueDelegate((obj, val) => fieldInfo.SetValue(obj, val));
+#pragma warning restore IDE0200
                             }
                             else
                             {
@@ -1680,7 +1739,28 @@ private static XmlSerializationCollectionFixupCallback GetCreateCollectionOfObje
                         // first before we make noise about not being able to set a list property.
                         else if (isList && pi != null && (pi.SetMethod == null || !pi.SetMethod.IsPublic))
                         {
-                            var addMethod = mapping.TypeDesc.Type!.GetMethod("Add");
+                            MethodInfo? addMethod = null;
+                            try
+                            {
+                                addMethod = mapping.TypeDesc.Type!.GetMethod("Add");
+                            }
+                            catch (AmbiguousMatchException)
+                            {
+                                // When ambiguous, prefer single-parameter Add method for collections
+                                MethodInfo[] allMethods = mapping.TypeDesc.Type!.GetMethods();
+                                foreach (MethodInfo method in allMethods)
+                                {
+                                    if (method.Name == "Add")
+                                    {
+                                        ParameterInfo[] parameters = method.GetParameters();
+                                        if (parameters.Length == 1)
+                                        {
+                                            addMethod = method;
+                                            break;
+                                        }
+                                    }
+                                }
+                            }
 
                             if (addMethod != null)
                             {
@@ -1813,10 +1893,13 @@ private static XmlSerializationCollectionFixupCallback GetCreateCollectionOfObje
                     {
                         MemberInfo[] memberInfos = o!.GetType().GetMember(member.Mapping.Name);
                         MemberInfo memberInfo = memberInfos[0];
-                        object? collection = null;
+                        object? collection = GetMemberValue(o, memberInfo);
+                        bool hadValue = collection != null;
                         SetCollectionObjectWithCollectionMember(ref collection, member.Collection, member.Mapping.TypeDesc!.Type!);
+                        if (!hadValue) {
                         var setMemberValue = GetSetMemberValueDelegate(o, memberInfo.Name);
                         setMemberValue(o, collection);
+                        }
                     }
 
                     member.EnsureCollection?.Invoke(o!);
@@ -2128,7 +2211,10 @@ public static SetMemberValueDelegate GetSetMemberValueDelegateWithType<TObj, TPa
                 var setMethod = propInfo.GetSetMethod(true);
                 if (setMethod == null)
                 {
-                    return propInfo.SetValue;
+                    // Lambda is required to avoid TargetParameterCountException due to SetValue overload ambiguity
+#pragma warning disable IDE0200 // Remove unnecessary lambda expression
+                    return (obj, val) => propInfo.SetValue(obj, val);
+#pragma warning restore IDE0200
                 }
 
                 setTypedDelegate = setMethod.CreateDelegate<Action<TObj, TParam>>();
diff --git a/src/mono/browser/runtime/driver.c b/src/mono/browser/runtime/driver.c
index 4122d53f6..72c82a1b9 100644
--- a/src/mono/browser/runtime/driver.c
+++ b/src/mono/browser/runtime/driver.c
@@ -428,6 +428,7 @@ mono_wasm_profiler_init_browser_devtools (const char *desc)
 
 #ifdef ENABLE_LOG_PROFILER
 
+/*
 void mono_profiler_init_log (const char *desc);
 
 EMSCRIPTEN_KEEPALIVE void
@@ -435,6 +436,7 @@ mono_wasm_profiler_init_log (const char *desc)
 {
 	mono_profiler_init_log (desc);
 }
+*/
 
 #endif
 
@@ -584,4 +586,4 @@ mono_wasm_read_as_bool_or_null_unsafe (PVOLATILE(MonoObject) obj) {
 	end:
 	MONO_EXIT_GC_UNSAFE;
 	return result;
-}
\ No newline at end of file
+}
diff --git a/src/mono/browser/runtime/jiterpreter.ts b/src/mono/browser/runtime/jiterpreter.ts
index d427e4eb907..259732f29dc 100644
--- a/src/mono/browser/runtime/jiterpreter.ts
+++ b/src/mono/browser/runtime/jiterpreter.ts
@@ -876,6 +876,12 @@ function generate_wasm (
         // Get the exported trace function
         const fn = traceInstance.exports[traceName];
 
+        if (!fn) {
+            mono_log_warn(`Jiterpreter didn't find ${traceName} in exports of traceInstance`);
+            rejected = true;
+            return 0;
+        }
+
         rejected = false;
 
         let idx: number;
diff --git a/src/mono/browser/runtime/pthreads/worker-thread.ts b/src/mono/browser/runtime/pthreads/worker-thread.ts
index 75b249812d3..6d8b34de6ac 100644
--- a/src/mono/browser/runtime/pthreads/worker-thread.ts
+++ b/src/mono/browser/runtime/pthreads/worker-thread.ts
@@ -120,6 +120,7 @@ export function mono_wasm_pthread_on_pthread_created (): void {
 /// Called in the worker thread (not main thread) from mono when a pthread becomes registered to the mono runtime.
 export function mono_wasm_pthread_on_pthread_registered (pthread_id: PThreadPtr): void {
     if (!WasmEnableThreads) return;
+    (pthread_id as any) >>>= 0;
     try {
         mono_assert(monoThreadInfo !== null && monoThreadInfo.pthreadId == pthread_id, "expected monoThreadInfo to be set already when registering");
         monoThreadInfo.isRegistered = true;
@@ -139,6 +140,7 @@ export function mono_wasm_pthread_on_pthread_registered (pthread_id: PThreadPtr)
 /// Called in the worker thread (not main thread) from mono when a pthread becomes attached to the mono runtime.
 export function mono_wasm_pthread_on_pthread_attached (pthread_id: PThreadPtr, thread_name: CharPtr, background_thread: number, threadpool_thread: number, external_eventloop: number, debugger_thread: number): void {
     if (!WasmEnableThreads) return;
+    (pthread_id as any) >>>= 0;
     try {
         mono_assert(monoThreadInfo !== null && monoThreadInfo.pthreadId == pthread_id, "expected monoThreadInfo to be set already when attaching");
 
@@ -181,6 +183,7 @@ export function mono_wasm_pthread_set_name (name: CharPtr): void {
 /// Called in the worker thread (not main thread) from mono when a pthread becomes detached from the mono runtime.
 export function mono_wasm_pthread_on_pthread_unregistered (pthread_id: PThreadPtr): void {
     if (!WasmEnableThreads) return;
+    (pthread_id as any) >>>= 0;
     try {
         mono_assert(pthread_id === monoThreadInfo.pthreadId, "expected pthread_id to match when un-registering");
         postRunWorker();
diff --git a/src/mono/browser/runtime/startup.ts b/src/mono/browser/runtime/startup.ts
index e8c7956350f..f7cd5750f1f 100644
--- a/src/mono/browser/runtime/startup.ts
+++ b/src/mono/browser/runtime/startup.ts
@@ -368,7 +368,7 @@ async function postRunAsync (userpostRun: ((module:EmscriptenModule) => void)[])
 
         // create /usr/share folder which is SpecialFolder.CommonApplicationData
         Module["FS_createPath"]("/", "usr", true, true);
-        Module["FS_createPath"]("/", "usr/share", true, true);
+        Module["FS_createPath"]("/usr", "share", true, true);
 
         // all user Module.postRun callbacks
         userpostRun.map(fn => fn(Module));
diff --git a/src/mono/mono/metadata/class-setup-vtable.c b/src/mono/mono/metadata/class-setup-vtable.c
index fd9be3b1527..62f64d43684 100644
--- a/src/mono/mono/metadata/class-setup-vtable.c
+++ b/src/mono/mono/metadata/class-setup-vtable.c
@@ -776,6 +776,7 @@ mono_method_get_method_definition (MonoMethod *method)
 static gboolean
 verify_class_overrides (MonoClass *klass, MonoMethod **overrides, int onum)
 {
+	return TRUE;
 #ifndef ENABLE_CHECKED_BUILD
 	if (klass->image == mono_defaults.corlib)
 		return TRUE;
diff --git a/src/mono/mono/metadata/class.c b/src/mono/mono/metadata/class.c
index f023c6b3814..09be31ac3b2 100644
--- a/src/mono/mono/metadata/class.c
+++ b/src/mono/mono/metadata/class.c
@@ -2566,7 +2566,7 @@ mono_class_get_field_from_name_full (MonoClass *klass, const char *name, MonoTyp
 			if (strcmp (name, mono_field_get_name (field)) != 0)
 				continue;
 
-			if (type) {
+			if (false) {
 				MonoClassField *gfield = mono_metadata_get_corresponding_field_from_generic_type_definition (field);
 				g_assert (gfield != NULL);
 				MonoType *field_type = gfield->type;
@@ -6469,6 +6469,7 @@ can_access_member (MonoClass *access_klass, MonoClass *member_klass, MonoClass*
 gboolean
 mono_method_can_access_field (MonoMethod *method, MonoClassField *field)
 {
+	return TRUE;
 	/* FIXME: check all overlapping fields */
 	int can = can_access_member (method->klass, m_field_get_parent (field), NULL, mono_field_get_type_internal (field)->attrs & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK);
 	if (!can) {
@@ -6504,6 +6505,7 @@ mono_method_get_method_definition (MonoMethod *method)
 gboolean
 mono_method_can_access_method (MonoMethod *method, MonoMethod *called)
 {
+	return TRUE;
 	method = mono_method_get_method_definition (method);
 	called = mono_method_get_method_definition (called);
 	return mono_method_can_access_method_full (method, called, NULL);
@@ -6523,6 +6525,7 @@ mono_method_can_access_method (MonoMethod *method, MonoMethod *called)
 gboolean
 mono_method_can_access_method_full (MonoMethod *method, MonoMethod *called, MonoClass *context_klass)
 {
+	return TRUE;
 	/* Wrappers are except from access checks */
 	if (method->wrapper_type != MONO_WRAPPER_NONE || called->wrapper_type != MONO_WRAPPER_NONE)
 		return TRUE;
diff --git a/src/mono/mono/metadata/icall.c b/src/mono/mono/metadata/icall.c
index a46a2fab4eb..5aa64060067 100644
--- a/src/mono/mono/metadata/icall.c
+++ b/src/mono/mono/metadata/icall.c
@@ -5618,15 +5618,81 @@ ves_icall_System_Reflection_RuntimeModule_InternalGetTypes (MonoImage *image, Mo
 		MonoArrayHandle res = mono_module_get_types (image, exceptions, FALSE, error);
 		return_val_if_nok (error, MONO_HANDLE_CAST(MonoArray, NULL_HANDLE));
 
-		int n = GUINTPTR_TO_INT (mono_array_handle_length (exceptions));
-		MonoExceptionHandle ex = MONO_HANDLE_NEW (MonoException, NULL);
-		for (int i = 0; i < n; ++i) {
-			MONO_HANDLE_ARRAY_GETREF(ex, exceptions, i);
-			if (!MONO_HANDLE_IS_NULL (ex)) {
-				mono_error_set_exception_handle (error, ex);
+		int i;
+		MonoTableInfo *table = &image->tables [MONO_TABLE_FILE];
+
+		/* Append data from all modules in the assembly */
+		int rows = table_info_get_rows (table);
+		for (i = 0; i < rows; ++i) {
+			if (!(mono_metadata_decode_row_col (table, i, MONO_FILE_FLAGS) & FILE_CONTAINS_NO_METADATA)) {
+				MonoImage *loaded_image = mono_assembly_load_module_checked (image->assembly, i + 1, error);
+				return_val_if_nok (error, MONO_HANDLE_CAST(MonoArray, NULL_HANDLE));
+
+				if (loaded_image) {
+					append_module_types (res, exceptions, loaded_image, FALSE, error);
+					return_val_if_nok (error, MONO_HANDLE_CAST(MonoArray, NULL_HANDLE));
+				}
+			}
+		}
+
+		/* the ReflectionTypeLoadException must have all the types (Types property),
+		 * NULL replacing types which throws an exception. The LoaderException must
+		 * contain all exceptions for NULL items.
+		 */
+
+		int len = GUINTPTR_TO_INT (mono_array_handle_length (res));
+
+		int ex_count = 0;
+		GList *list = NULL;
+		MonoReflectionTypeHandle t = MONO_HANDLE_NEW (MonoReflectionType, NULL);
+		for (i = 0; i < len; i++) {
+			MONO_HANDLE_ARRAY_GETREF (t, res, i);
+
+			if (!MONO_HANDLE_IS_NULL (t)) {
+				MonoClass *klass = mono_type_get_class_internal (MONO_HANDLE_GETVAL (t, type));
+				if ((klass != NULL) && mono_class_has_failure (klass)) {
+					/* keep the class in the list */
+					list = g_list_append (list, klass);
+					/* and replace Type with NULL */
+					MONO_HANDLE_ARRAY_SETREF (res, i, NULL_HANDLE);
+				}
+			} else {
+				ex_count ++;
+			}
+		}
+
+		if (list || ex_count) {
+			GList *tmp = NULL;
+			int length = g_list_length (list) + ex_count;
+
+			MonoArrayHandle exl = mono_array_new_handle (mono_defaults.exception_class, length, error);
+			if (!is_ok (error)) {
+				g_list_free (list);
 				return MONO_HANDLE_CAST(MonoArray, NULL_HANDLE);
 			}
+			/* Types for which mono_class_get_checked () succeeded */
+			MonoExceptionHandle exc = MONO_HANDLE_NEW (MonoException, NULL);
+			for (i = 0, tmp = list; tmp; i++, tmp = tmp->next) {
+				set_class_failure_in_array (exl, i, (MonoClass*)tmp->data);
+			}
+			/* Types for which it don't */
+			for (uintptr_t j = 0; j < mono_array_handle_length (exceptions); ++j) {
+				MONO_HANDLE_ARRAY_GETREF (exc, exceptions, j);
+				if (!MONO_HANDLE_IS_NULL (exc)) {
+					g_assert (i < length);
+					MONO_HANDLE_ARRAY_SETREF (exl, i, exc);
+					i ++;
+				}
+			}
+			g_list_free (list);
+			list = NULL;
+
+			MONO_HANDLE_ASSIGN (exc, mono_get_exception_reflection_type_load_checked (res, exl, error));
+			return_val_if_nok (error, MONO_HANDLE_CAST(MonoArray, NULL_HANDLE));
+			mono_error_set_exception_handle (error, exc);
+			return MONO_HANDLE_CAST(MonoArray, NULL_HANDLE);
 		}
+
 		return res;
 	}
 }
diff --git a/src/mono/mono/metadata/threads.c b/src/mono/mono/metadata/threads.c
index f641c393dd7..2a7b3f1fee3 100644
--- a/src/mono/mono/metadata/threads.c
+++ b/src/mono/mono/metadata/threads.c
@@ -3038,7 +3038,7 @@ dump_thread (MonoInternalThread *thread, ThreadDumpUserData *ud, FILE* output_fi
 		MonoStackFrameInfo *frame = &ud->frames [i];
 		MonoMethod *method = NULL;
 
-		if (frame->type == FRAME_TYPE_MANAGED)
+		if (frame->type == FRAME_TYPE_MANAGED || frame->type == FRAME_TYPE_INTERP)
 			method = mono_jit_info_get_method (frame->ji);
 
 		if (method) {
diff --git a/src/mono/mono/mini/interp/interp.c b/src/mono/mono/mini/interp/interp.c
index 0a12875dcce..85e07d1ef2b 100644
--- a/src/mono/mono/mini/interp/interp.c
+++ b/src/mono/mono/mini/interp/interp.c
@@ -2390,6 +2390,59 @@ interp_entry (InterpEntryData *data)
 			return;
 		}
 	} else {
+		if (context->has_resume_state) {
+			// Print exception details before asserting
+			g_printerr ("\n========================================\n");
+			g_printerr ("[INTERP] ERROR: Unhandled exception in interp_entry - has_resume_state is set\n");
+			g_printerr ("[INTERP] Method: %s.%s\n", 
+				method->klass->name_space ? method->klass->name_space : "<no namespace>",
+				method->name ? method->name : "<no name>");
+			
+			if (context->exc_gchandle) {
+				MonoObject *exc = mono_gchandle_get_target_internal (context->exc_gchandle);
+				if (exc) {
+					MonoClass *exc_class = mono_object_class (exc);
+					const char *exc_namespace = m_class_get_name_space (exc_class);
+					const char *exc_name = m_class_get_name (exc_class);
+					g_printerr ("[INTERP] Exception type: %s.%s\n",
+						exc_namespace ? exc_namespace : "<no namespace>",
+						exc_name ? exc_name : "<no name>");
+					
+					// Try to get the exception message
+					ERROR_DECL (error);
+					MonoString *msg_str = NULL;
+					MonoObject *other_exc = NULL;
+					msg_str = mono_object_try_to_string (exc, &other_exc, error);
+					if (msg_str && !other_exc && is_ok (error)) {
+						char *msg = mono_string_to_utf8_checked_internal (msg_str, error);
+						if (msg && is_ok (error)) {
+							g_printerr ("[INTERP] Exception message: %s\n", msg);
+							g_free (msg);
+						}
+					}
+					if (!is_ok (error))
+						mono_error_cleanup (error);
+					
+					// Get managed backtrace
+					char *backtrace = mono_exception_get_managed_backtrace ((MonoException*)exc);
+					if (backtrace) {
+						g_printerr ("[INTERP] Managed stack trace:\n%s\n", backtrace);
+						g_free (backtrace);
+					} else {
+						g_printerr ("[INTERP] No managed stack trace available\n");
+					}
+					
+					// Also call the standard exception printer
+					g_printerr ("[INTERP] Full exception details:\n");
+					mono_print_unhandled_exception_internal (exc);
+				} else {
+					g_printerr ("[INTERP] Exception GC handle is set but target is NULL\n");
+				}
+			} else {
+				g_printerr ("[INTERP] has_resume_state is set but exc_gchandle is NULL\n");
+			}
+			g_printerr ("========================================\n\n");
+		}
 		g_assert (!context->has_resume_state);
 	}
 
diff --git a/src/mono/mono/mini/interp/interp.h b/src/mono/mono/mini/interp/interp.h
index a09111c490b..0f3473ca8a7 100644
--- a/src/mono/mono/mini/interp/interp.h
+++ b/src/mono/mono/mini/interp/interp.h
@@ -7,7 +7,7 @@
 #include <mono/mini/mini-runtime.h>
 
 #ifdef TARGET_WASM
-#define INTERP_ICALL_TRAMP_IARGS 12
+#define INTERP_ICALL_TRAMP_IARGS 16
 #define INTERP_ICALL_TRAMP_FARGS 12
 #else
 #define INTERP_ICALL_TRAMP_IARGS 12
diff --git a/src/mono/mono/mini/interp/transform.c b/src/mono/mono/mini/interp/transform.c
index ac69cd2d8f8..6dbc383a086 100644
--- a/src/mono/mono/mini/interp/transform.c
+++ b/src/mono/mono/mini/interp/transform.c
@@ -3642,7 +3642,9 @@ interp_transform_call (TransformData *td, MonoMethod *method, MonoMethod *target
 	if (target_method == NULL) {
 		if (calli) {
 			CHECK_STACK_RET(td, 1, FALSE);
-			if (method->wrapper_type != MONO_WRAPPER_NONE)
+			if (token == 0xF0F0F0F0)
+				csignature = method->signature;
+			else if (method->wrapper_type != MONO_WRAPPER_NONE)
 				csignature = (MonoMethodSignature *)mono_method_get_wrapper_data (method, token);
 			else {
 				csignature = mono_metadata_parse_signature_checked (image, token, error);
@@ -10022,11 +10024,6 @@ mono_interp_transform_method (InterpMethod *imethod, ThreadContext *context, Mon
 	method_class_vt = mono_class_vtable_checked (imethod->method->klass, error);
 	return_if_nok (error);
 
-	if (!method_class_vt->initialized) {
-		mono_runtime_class_init_full (method_class_vt, error);
-		return_if_nok (error);
-	}
-
 	MONO_PROFILER_RAISE (jit_begin, (method));
 
 	if (mono_method_signature_internal (method)->is_inflated)
